---
title: Flutter CleanArchitecture + MVVM + riverpod 적용 정리  (1)
date: 2024-11-24 17:10:01 +0900
categories:
  - devlogs
tags:
  - flutter
  - cleanarchitecture
  - mvvm
  - riverpod
---
### 왜 적용하는가?

플러터 사이트 프로젝트를 작업 중 오랜만에 작업을 하려고 했더니 다소 복잡한 감이 있어 정리를 해야겠다 마음먹었다. 적용을 하다가 생각보다 헷갈리는 느낌들이 있어서 정리를 해야겠다는 생각이 들었다. 이를 위해서 Udemy에서 플러터 클린아키텍처, 플러터 MVVM, 플러터 Riverpod 강의를 살펴봤다. 강의에서 제공하는 소스 코드를 뜯어보면서 내 사이드 프로젝트에 천천천히 적용해보았다. 그리고 그에 대한 정리를 글로 남긴다.



### 이해하기 힘든 Layer들

살펴보니 domain, data, presentation 으로 크게 구조를 나누고 있고 이를 Layer로 지칭하고 있다. 이 레이어들은 종종 다른 이름으로 불리기도 하는 듯 하여 처음에는 꽤 이해가 힘들었다. 저 3개의 레이어가 무엇을 의미하는지 정리할 필요가 있다.



### 클린아키텍처 세 레이어에 대한 정리

세 레이어가 아무래도 한국인이다 보니 영어로는 직관적으로 느껴지지 않아서, 한글로 정리를 다시 해보았다.

1. data로 불리는 LocalDB 접속, 외부 API 접속을 담당하는 레이어 -> 외부저장소 레이어
2. domain으로 불리는 프로그램에 대한 것들을 추상화한 레이어 -> 프로그램 레이어
3. Presentation으로 불리는 -> 사용자 레이어

![](../../media/attachments/Pasted%20image%2020241124180717.png)

이렇게 정리를 한 기준은 각 레이어들이 사람이라면 레이어가 상대하는 고객이 누구일까에 대한 고민을 기준으로 정리했다. 왜냐하면 우리가 결국 어떠한 판단을 가지고 소스코드, 폴더, 데이터 등을 각 레이어에 맞춰넣어야 하는데 필연적으로 레이어의 고객이 누구인지 알아야하기때문이다. 모든 요구사항은 고객으로부터 나오니깐 말이다.

이렇게 정리를 하게되면 생각보다 각 레이어에 속하는게 무엇일지 예상하는게 한결 편안해진다.

presentation, domain, data가 각 레이어의 책임과 역할을 추상화한 네이밍이라면 나는 각 레이어의 고객으로 일단 생각해보겠다.



### Data Layer, 외부저장소가가 고객인 레이어

Data Layer의 폴더 구조를 살펴본다. 보통 아래와 같이 나누는 듯 하다.

- /models
- /datasources
- /repositories
#### DataLayer/Models

models는 외부저장소에서 쓰일 데이터 모델들이 들어가게 된다. 만약 외부저장소가 서버를 향한다면 서버와 소통하기 위한 DTO(data transfer object) Model 들이 들어있게 되겠다. 만약 해당 레이어의 고객이 Local DB라면 Local DB의 DataModel들이 들어갈것이다. 고객이 서버와 LocalDB라면 각각의 모델들을 폴더를 나눠 정리해볼수도 있을 것이다.

model들은 고객에 맞게 커스텀된 계약서 정도로 생각하면 알맞을것같다.

#### DataLayer/Datasources

Datasources는 고객과의 업무를 위한 접객실 정도로 생각을 해봤다. 접객실에는 서버라는 손님이 올수도 있고 Sqlite 같은 손님이 올수도 있다. 만약 서버라면 서버를 상대하기위한 API를 구현하는 로직이 담길것이고, DB라면 DB를 상대하기 위한 DB로직이 들어갈것이다.

근데 또 DB가 MariaDB일수도있고  MYSQL일수도 있으니 일단 DB용 접객 문서, 즉 인터페이스를 구현해놓아야한다.


#### DataLayer/Repositories

Repository는 사장님이 Layer들에게 시킨 일들이라고 보면된다. 사장님이 Layer에게 Login이라는 일을 시켰고. Layer는 Repository폴더에 그 일들을 실행한다. 근데 Login이라는 일을 하려면 필연적으로 Datasources에 있는 고객들과 협조를 해야한다. DB 고객들이 실질적으로 데이터를 가져오는 일을 하고 DataLayer는 Repository에서 사장님이 시킨 일을 실질적으로 끝마칠수 있다.


### DomainLayer, 프로그램이 고객인 레이어

도메인 레이어의 고객은 프로그램이다. 그래서 이 레이어에는 프로그램과 직접적으로 관련된 것들이 온다. 프로그램 내에서 사용되는 데이터들, 프로그램 내에서 사용되는 로직들 등...

도메인 레이어는 보통 아래의 폴더 구조를 가진다.

- DomainLayer/Entities
- DomainLayer/Usecases
- DomainLayer/Repositories

#### DomainLayer/Entities

엔티티가 처음엔 햇갈렸다. 굳이 설명하자면 여기에도 데이터 모델이 들어간다. 앞서 설명한 DataLayer의 DataModel들과 근본은 똑같다. 하지만 사용 고객이 다르다는게 중요하다. DomainLayer의 고객은 프로그램이고 DataModel또한 고객 맞춤형으로 내놓아야햔다.

왜 굳이 레이어를 둘로 나누어 비슷한 데이터 모델을 작성해야 할까? 프로그램이 만약 DataLayer의 고객이었던 DB의 DataModel을 동일하게 사용하고 있는 상황이다.. 그리고 DataLayer의 원래 고객인 MySQL이 갑자기 MongoDB로 변경되었고 그에 맞춰 데이터 모델 또한 대대적인 변경이 됐다. 이 때 DomainLayer의 프로그램은 여전히 MySQL의 DataModel을 사용하고 있었는데... DomainLayer는 너무 당황스러울것이다. 당장 프로그램에게 찾아가 사정사정해서 여기가 바뀌었으니 고쳐야한다고 알려줘야하니깐 말이다. 

#### DomainLayer/Usecases

Usecases에는 실제 프로그램의 로직들이 들어간다. 예를 들면 출석 앱이면 출석을 체크하는 로직이 들어갈것이다. 

- Usecases/CheckUsecase.cs

도메인 레이어는 프로그램에게 무엇을 어떻게 해야하는지 알려주는 서비스를 제공한다. 프로그램이 출석앱이라면 출석체크, 출석조회 이렇게 두 가지 일을 할것이다. 도메인 레이어는 이 두 일에 대한 방법까지 포함해서 제공한다.


#### DomainLayer/Repositories

도메인 레이어는 프로그램이 해야 될 일 뿐 아니라, 프로그램이 혼자서 완수하지 못 할 일들의 외주도 구해야한다. 그러기 위해서 요구사항을 일단 정리해놓는다. 예를 들어 출석 체크를 위해 출석 체크할 사람들의 목록을 가져오기가 있다. 프로그램은 그냥 주어진 목록에 출석 체크해주는 기능만 하고 목록을 가져오는 일은 하지 않기 때문이다.

때문에 도메인 레이어는 일단 요구사항, 즉 필요한 일들에 대한 명세만 가지고 있게 된다. 이게 바로 Repositories에 Interface가 위치하는 이유이다. DataLayer의 Repositories에서는 이 요구사항을 토대로 실제로 일을 하게 되는 것이다.


$$
... 글을 천천히 작성 중입니다 ...
$$

