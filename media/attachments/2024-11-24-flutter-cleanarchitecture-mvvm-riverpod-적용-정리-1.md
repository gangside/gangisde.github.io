---
title: Flutter CleanArchitecture + MVVM + riverpod 적용 정리  (1)
date: 2024-11-24 17:10:01 +0900
categories:
  - devlogs
tags:
  - flutter
  - cleanarchitecture
  - mvvm
  - riverpod
imageNameKey: 2024-11-24-flutter-cleanarchitecture-mvvm-riverpod-적용-정리-1
---
>- 플러터앱에 클린아키텍처+MVVM+Riverpod 적용하면서 학습한 내용의 정리와 후기에 대한 글입니다.
{: .prompt-info }

### 이해하기 어려운 레이어 개념들

클린아키텍처를 살펴보니 도메인 레이어, 데이터 레이어, 프리젠테이션 레이어로 구성된다. 이 레이어들은 종종 다른 이름으로 불리는 모습을 봤기 때문에 처음에는 이해가 힘들었다. 어쨌든 저 3개의 레이어가 무엇을 의미하는지 정리해보려고한다.



### 클린아키텍처 세 레이어에 대한 정리

세 레이어가 아무래도 영어로는 직관적으로 느껴지지 않아서, 한글로 정리를 다시 해보았다. 정리의 기준은 기존의 추상적인 이름이 아닌 레이어의 주요 사용자, 여기서는 레이어의 고객이 누구인지에 집중해 정리해봤다.

1. data layer  => 외부 저장소 레이어
	- 데이터를 다루는 레이어다. 이 레이어의 주 고객은 외부 저장소이다. 
2. domain layer => 프로그램 레이어
	- domain layer는 프로그램의 도메인을 의미한다. 즉 이 레이어의 고객은 프로그램 그 자체이다.
3. presentation layer => 사용자 레이어
	- presentation layer는 직역하면 표현 계층 정도로 표현되는데, 표현이란 말이 굉장히 추상적이다. 표현을 누구한테 한다는 말인가? 바로 사용자다. 이 레이어의 고객은 사용자이다.

![](media/attachments/2024-11-24-flutter-cleanarchitecture-mvvm-riverpod-적용-정리-1-20241124.png)

이렇게 각 레이어의 고객들이 누구인지 정함으로써 레이어의 존재이유와 목표를 확인할수있었다. 그리고 우리는 이 판단을 가지고 소스코드, 폴더, 데이터 등을 각 레이어에 맞춰 넣을 수 있을 것이다.


### 데이터 레이어, 외부저장소가 고객인 레이어

데이터 레이어의 폴더 구조를 살펴본다. 보통 아래와 같이 나누는 듯 하다.

- /models
- /datasources
- /repositories

#### 데이터 레이어 / Models

Models는 데이터 레이어에서 사용 될 모델들이 들어가게 된다. 데이터 레이어의 고객은 외부저장소이다. 고객은 바뀔 수 있다. 고객들은 모두 데이터를 다루는 사람들이다. 만약 고객이 서버라면 Models에는 패킷 데이터나 DTO 모델이 들어갈것이다. 만약 고객이 MYSQL 이라면 일반적인 데이터 모델이 사용될것이다.

중요한건 고객인 서버나 DB마다 원하는 데이터 형식이 다를 수 있다는 점이고 이러한 부분에 필요한 데이터 형식이 무엇인지 확인해야한다는 점이다.


#### DataLayer/Datasources

Datasources는 저장소 고객과의 업무를 위한 접객실 정도로 생각을 해봤다. 접객실에는 서버라는 손님이 올수도 있고  같은 손님이 올수도 있다. 만약 서버라면 서버를 상대하기위한 API를 구현하는 로직이 담길것이고, DB라면 DB를 상대하기 위한 DB로직이 들어갈것이다.

근데 또 DB가 MariaDB일수도있고  MYSQL일수도 있으니 일단 DB용 접객 문서, 즉 인터페이스를 구현해놓아야한다.


#### DataLayer/Repositories

Repository는 사장님이 Layer들에게 시킨 일들이라고 보면된다. 사장님이 Layer에게 Login이라는 일을 시켰고. Layer는 Repository폴더에 그 일들을 실행한다. 근데 Login이라는 일을 하려면 필연적으로 Datasources에 있는 고객들과 협조를 해야한다. DB 고객들이 실질적으로 데이터를 가져오는 일을 하고 DataLayer는 Repository에서 사장님이 시킨 일을 실질적으로 끝마칠수 있다.


### DomainLayer, 프로그램이 고객인 레이어

도메인 레이어의 고객은 프로그램이다. 그래서 이 레이어에는 프로그램과 직접적으로 관련된 것들이 온다. 프로그램 내에서 사용되는 데이터들, 프로그램 내에서 사용되는 로직들 등...

도메인 레이어는 보통 아래의 폴더 구조를 가진다.

- DomainLayer/Entities
- DomainLayer/Usecases
- DomainLayer/Repositories

#### DomainLayer/Entities

엔티티가 처음엔 햇갈렸다. 굳이 설명하자면 여기에도 데이터 모델이 들어간다. 앞서 설명한 DataLayer의 DataModel들과 근본은 똑같다. 하지만 사용 고객이 다르다는게 중요하다. DomainLayer의 고객은 프로그램이고 DataModel또한 고객 맞춤형으로 내놓아야햔다.

왜 굳이 레이어를 둘로 나누어 비슷한 데이터 모델을 작성해야 할까? 프로그램이 만약 DataLayer의 고객이었던 DB의 DataModel을 동일하게 사용하고 있는 상황이다.. 그리고 DataLayer의 원래 고객인 MySQL이 갑자기 MongoDB로 변경되었고 그에 맞춰 데이터 모델 또한 대대적인 변경이 됐다. 이 때 DomainLayer의 프로그램은 여전히 MySQL의 DataModel을 사용하고 있었는데... DomainLayer는 너무 당황스러울것이다. 당장 프로그램에게 찾아가 사정사정해서 여기가 바뀌었으니 고쳐야한다고 알려줘야하니깐 말이다. 

#### DomainLayer/Usecases

Usecases에는 실제 프로그램의 로직들이 들어간다. 예를 들면 출석 앱이면 출석을 체크하는 로직이 들어갈것이다. 

- Usecases/CheckUsecase.cs

도메인 레이어는 프로그램에게 무엇을 어떻게 해야하는지 알려주는 서비스를 제공한다. 프로그램이 출석앱이라면 출석체크, 출석조회 이렇게 두 가지 일을 할것이다. 도메인 레이어는 이 두 일에 대한 방법까지 포함해서 제공한다.


#### DomainLayer/Repositories

도메인 레이어는 프로그램이 해야 될 일 뿐 아니라, 프로그램이 혼자서 완수하지 못 할 일들의 외주도 구해야한다. 그러기 위해서 요구사항을 일단 정리해놓는다. 예를 들어 출석 체크를 위해 출석 체크할 사람들의 목록을 가져오기가 있다. 프로그램은 그냥 주어진 목록에 출석 체크해주는 기능만 하고 목록을 가져오는 일은 하지 않기 때문이다.

때문에 도메인 레이어는 일단 요구사항, 즉 필요한 일들에 대한 명세만 가지고 있게 된다. 이게 바로 Repositories에 Interface가 위치하는 이유이다. DataLayer의 Repositories에서는 이 요구사항을 토대로 실제로 일을 하게 되는 것이다.


$$
... 글을 천천히 작성 중입니다 ...
$$

